---
title: "My Answer for exercise1"
author: "Ai Zhang"
date: "2026-02-03"
output: html_document
---


## beginning 

```{r}
install.packages('tidyverse')
install.packages('tidytext')
install.packages('ggthemes')
install.packages('readr')
install.packages('babynames')
```

```{r}
library(tidyverse) # loads dplyr, ggplot2, and others
library(tidytext) # includes set of functions useful for manipulating text
library(ggthemes) # includes a set of themes to make your visualizations look nice!
library(readr) # more informative and easy way to import data
library(babynames) #for gender predictions
```
```{r}
edbfdata <- read_csv("https://raw.githubusercontent.com/cjbarrie/RDL-Ed/main/02-text-as-data/data/edbookfestall.csv")
```
## Inspect and filter data

Our next job is to cut down this dataset to size, including only those columns that we need. But first we can inspect it to see what the existing column names are, and how each variable is coded.
```{r}
# 返回数据框edbfdata的所有列名
colnames(edbfdata)
```
```{r}
# 纵向展示行数/列数/每个列名下的数据类型和前几个示例值
glimpse(edbfdata)
```
We can see that the description of each event is included in a column named “description” and the year of that event as “year.” So for now we’ll just keep these two. 
We use pipe %>% functions in the tidyverse package to quickly and efficiently select the columns we want from the edbfdata data.frame object. We pass this data to a new data.frame object, which we call “evdes.”
```{r}
# 只保留description和year两个变量，生成一个新的数据集evdes
# pipe %>% 指示句子的阅读逻辑，从左向右，可以可以接更多管道连接更多后续处理逻辑
evdes <- edbfdata %>% select(description, year)
head(evdes)
```

And let’s take a quick look at how many events there were over time at the festival. To do this, we first calculate the number of individual events (row observations) by year (column variable).
```{r}
# 按year进行分组，统计每一年分别发生了多少事件
# mutate(obs=1)，给每一行新加一列obs，值全部是 1，方便通过求和来进行计数
# group_by(year)，按年份分组，使后一句的summarise()按指定group来求和
# summarise(sum_events = sum(obs))，在每个年份组内，把obs全部加起来
evtsperyr <- evdes %>%
  mutate(obs=1) %>%
  group_by(year) %>%
  summarise(sum_events = sum(obs))
```

And then we can plot this using ggplot!
```{r}
ggplot(evtsperyr) +
  geom_line(aes(year, sum_events)) +
  theme_tufte(base_family = "Helvetica") + 
  scale_y_continuous(expand = c(0, 0), limits = c(0, NA))
```
## Tidy the text

get rid of any HTML and PHP encodings for e.g. bold font or paragraphs before the analysis because the data were obtained from an API that outputs data originally in HTML format
The below set of commands takes the event descriptions, extracts individual words, and counts the number of times they appear in each of the years covered by our book festival data.
```{r}
# get year and word for every word and date pair in the dataset
# 把evdes里面每一行的description转成全小写，并存成一个新列 desc
# tidytext 的核心函数，提取文本中的每个词并全部新标上年份，这一步顺便也会排除掉标点符号，以及会自动去掉文本原本的字体格式
# 只保留至少包含一个字母的token

tidy_des <- evdes %>% 
  mutate(desc = tolower(description)) %>%
  unnest_tokens(word, desc) %>%
  filter(str_detect(word, "[a-z]"))
```

在将文本 tidy 化之后，数据集的行数会显著增加，因为每一行现在代表一个词（term）。我们可以使用term定义document，term = 一个词（word / token）, document 是研究者人为定义的文本聚合单位，ducument的定义是研究设计的一部分。根据研究问题的不同，document 可以按年份、类型或作者来划分，而不同的 document 定义会对应不同的研究视角。

do a further tidy: delete stop words
```{r}
tidy_des <- tidy_des %>%
    filter(!word %in% stop_words$word)
```
```{r}
# 查看停用词类型
# 这是tidytext中的一个内置词库，里面都是不具有实质含义的语法词
stop_words
```
现在按词计数排序，看一下常用词
```{r}
tidy_des %>%
  count(word, sort = TRUE)
```

We can see that one of the most common words is “rsquo,” which is an HTML encoding for an apostrophe. This is a common issue in large-n text analysis and is a key step if you want to conduct reliably robust forms of text analysis. We’ll have another go using the the filter command, specifying that we only keep the words that are not included in the string of words rsquo, em, ndash, nbsp, lsquo.
```{r}
remove_reg <- c("&amp;","&lt;","&gt;","<p>", "</p>","&rsquo", "&lsquo;",  "&#39;", "<strong>", "</strong>", "rsquo", "em", "ndash", "nbsp", "lsquo", "strong")
                  
tidy_des <- tidy_des %>%
  filter(!word %in% remove_reg)
```

然后重新进行计数排序，正常了
```{r}
tidy_des %>%
  count(word, sort = TRUE)
```
Let’s now collect these words into a data.frame object, which we’ll call edbf_term_counts:
```{r}
edbf_term_counts <- tidy_des %>% 
  group_by(year) %>%
  count(word, sort = TRUE)
```
head it
```{r}
head(edbf_term_counts)
```

以上！！！就是非常重要的pre-processing and cleaning steps------------------------------------------------------------------------------

## Analyze keywords
Okay, now we have our list of words, and the number of times they appear, we can tag those words we think might be related to issues of gender inequality and sexism. You may decide that this list is imprecise or inexhaustive. If so, then feel free to change the terms we are including after the grepl() function.

正式开始，先基于关键词进行主题标注。为全部词汇打标签，如果这个词看起来与“性别不平等/性别歧视”相关 → 标记为 1；不相关 → 标记为 0；
edbf_term_counts$womword: 从前者取出后者为组件，提炼出一个新的列相当于
当然这个审判标准是主观决定的，使用grepl()检测一个字符串是否“包含某种模式”，并返回ture/false
使用正则表达式regex，|代表or，只要包含一下词汇中的任何一个，就算ture
as.integer()，将true/false进行1/0二元编码
```{r}
edbf_term_counts$womword <- as.integer(grepl("women|feminist|feminism|gender|harassment|sexism|sexist", 
                                            x = edbf_term_counts$word))
```
```{r}
head(edbf_term_counts)
```
## Compute aggregate statistics

we have tagged individual words relating to gender inequality and feminism, we can sum up the number of times these words appear each year and then denominate them by the total number of words in the event descriptions.
以年份为组别，统计每一年所有被标记词汇的总数，除以该年总词数，用性别相关词汇的占比衡量性别议题在文化生产中的“代表性”
```{r}
#get counts by year and word
edbf_counts <- edbf_term_counts %>%
  group_by(year) %>%
  mutate(year_total = sum(n)) %>%  # 创建一个新的列year_total（此时已经以年份为组了）
  filter(womword==1) %>%  # 选择标记为1的
  summarise(sum_wom = sum(n), # 把这一年里所有性别相关词的出现次数加起来，作为sum_wom
            year_total= min(year_total))  # 每一组只有一个total，所以这里写min/max都行
```
```{r}
head(edbf_counts)
```
## make a plot

Let’s take the count of words relating to gender in this dataset, and denominate them by the total number of words in these data per year.
And make a plot for it
```{r}
ggplot(edbf_counts, aes(year, sum_wom / year_total, group=1)) +
  geom_line() +
  xlab("Year") +
  ylab("% gender-related words") +
  scale_y_continuous(labels = scales::percent_format(),
                     expand = c(0, 0), limits = c(0, NA)) +
  theme_tufte(base_family = "Helvetica") 
```
We can add visual guides to draw attention to apparent changes in these data. Here, we might wish to signal the year of the #MeToo movement in 2017.
```{r}
ggplot(edbf_counts, aes(year, sum_wom / year_total, group=1)) +
  geom_line() +
  geom_vline(xintercept = 2017, col="red") +
  xlab("Year") +
  ylab("% gender-related words") +
  scale_y_continuous(labels = scales::percent_format(),
                     expand = c(0, 0), limits = c(0, NA)) +
  theme_tufte(base_family = "Helvetica")
```
And we could label why we are highlighting the year of 2017 by including a text label along the vertical line.
```{r}
ggplot(edbf_counts, aes(year, sum_wom / year_total, group=1)) +
  geom_line() +
  geom_vline(xintercept = 2017, col="red") +
  geom_text(aes(x=2017.1, label="#metoo year", y=.0015), 
            colour="black", angle=90, text=element_text(size=8)) +
  xlab("Year") +
  ylab("% gender-related words") +
  scale_y_continuous(labels = scales::percent_format(),
                     expand = c(0, 0), limits = c(0, NA)) +
  theme_tufte(base_family = "Helvetica")
```
## Bonus: gender prediction

之前用性别词汇占比衡量的方法 maybe is inadequate or too expansive to answer the question at hand
Another way of measuring representation in cultural production is to measure the gender of the authors who spoke at these events.
当然不能手动为每一场事件的主办标性别，我们“来基于名字推断性别”

We first create a new data.frame object, selecting just the columns for artist name and year. Then we generate a new column containing just the artist’s (author’s) first name:
```{r}
# get columns for artist name and year, omitting NAs
gendes <- edbfdata %>%
  select(artist, year) %>%
  na.omit() # 删除名字缺失的事件（行）

# generate new column with just the artist's (author's) first name
gendes$name <- sub(" .*", "", gendes$artist) # 提取first name
# sub(pattern, replacement, x) 的意思是：在字符串 x 中，找到第一次匹配 pattern 的地方，用 replacement 替换掉
# " .*" 表示从第一个空格开始，到字符串结尾的所有内容
# 使用""空字符串来替换，也就是从出现空格开始后面全删掉，也就是删掉所有last name
```

A set of packages called gender and genderdata used to make the process of predicting gender based on a given individual’s name pretty straightforward. This technique worked with reference to U.S. Social Security Administration baby name data.

Given that the most common gender associated with a given name changes over time, the function also allows us to specify the range of years for the cohort in question whose gender we are inferring. Given that we don’t know how wide the cohort of artists is that we have here, we could specify a broad range of 1920-2000.
```{r}
genpred <- gender(gendes$name,
       years = c(1920, 2000))
```

原始package以及不适用于新版本的R，以下根据babynames数据库重造一个替代包

## create babynames package

The babynames package. contains, for each year, the number of children born with a given name, as well as their sex. With this information, we can then calculate the total number of individuals with a given name born for each sex in a given year.

Given we also have the total number of babies born in total cross these records, we can denominate (divide) the sums for each name by the total number of births for each sex in each year. We can take this proportion as representing the probability that a given individual in our Edinburgh Fringe dataset is male or female.

We first load the babynames package into the R environment as a data.frame object. Because the data.frame “babynames” is contained in the babynames package we can just call it as an object and store it with .

This dataset contains names for all years over a period 1800–2019. The variable “n” represents the number of babies born with the given name and sex in that year, and the “prop” represents, according to the package materials accessible here, “n divided by total number of applicants in that year, which means proportions are of people of that gender with that name born in that year.”

```{r}
babynames <- babynames
head(babynames)
```
We then calculate the total number of babies of female and male sex born in each year. Then we merge these to get a combined dataset of male and female baby names by year. We then merge this information back into the original babynames data.frame object.

```{r}
totals_female <- babynames %>%
  filter(sex=="F") %>%
  group_by(year) %>%
  summarise(total_female = sum(n))

totals_male <- babynames %>%
  filter(sex=="M") %>%
  group_by(year) %>%
  summarise(total_male = sum(n))

totals <- merge(totals_female, totals_male)

totsm <- merge(babynames, totals, by = "year")
head(totsm)
```

We can then calculate, for all babies born on or after 1920, the number of babies born with that name and sex. With this information, we can then get the proportion of all babies with a given name that were of a particular sex. For example, if 92% of babies born with the name “Mary” were female, this would give us a .92 probability that an individual with the name “Mary” is female.

We do this for every name in the dataset, excluding names for which the proportion is equal to .5; i.e., for names that we cannot adjudicate between whether they are more or less likely male or female.

```{r}
totprops <- totsm %>%
  filter(year >= 1920) %>%
  group_by(name, year) %>%
  mutate(sumname = sum(n),
         prop = ifelse(sumname==n, 1,
                       n/sumname)) %>%
  filter(prop!=.5) %>%
  group_by(name) %>%
  slice(which.max(prop)) %>%
  summarise(prop = max(prop),
            totaln = sum(n),
            name = max(name),
            sex = unique(sex))

head(totprops)
```
## back to gender prediction
Once we have our proportions for all names, we can then merge these back with the names of our artists from the Edinburgh Fringe Book Festival. We can then easily plot the proportion of artists at the Festival who are male versus female in each year of the Festival.

```{r}
ednameprops <- merge(totprops, gendes, by = "name")

ggplot(ednameprops, aes(x=year, fill = factor(sex))) +
  geom_bar(position = "fill") +
  xlab("Year") +
  ylab("% women authors") +
  labs(fill="") +
  scale_y_continuous(labels = scales::percent_format(accuracy = 1)) +
  theme_tufte(base_family = "Helvetica") +
  geom_abline(slope=0, intercept=0.5,  col = "black",lty=2)
```

Note that when we merged the proportions from th “babynames” data with our Edinburgh Fringe data we lost some observations. This is because some names in the Edinburgh Fringe data had no match in the “babynames” data. That's a kind of potential biases. Let’s look at the names that had no match:
```{r}
names1 <- ednameprops$name
names2 <- gendes$name
diffs <- setdiff(names2, names1)
diffs
```




exercises
## A. Filter the books by genre (selecting e.g., “Literature” or “Children”) and plot frequency of women-related words over time.
```{r}
# Go through the same process. I've highlighted the differences
evdes_genre <- edbfdata %>%
  select(description, year, genre) # but include genre variable here

evtsperyr_genre <- evdes_genre %>%
  mutate(obs=1) %>%
  group_by(year, genre) %>% # group not only by year but also by genre
  summarise(sum_events = sum(obs))

tidy_des_genre <- evdes_genre %>% 
  mutate(desc = tolower(description)) %>%
  unnest_tokens(word, desc) %>%
  filter(str_detect(word, "[a-z]"))

tidy_des_genre <- tidy_des_genre %>%
  filter(!word %in% stop_words$word) %>%
  filter(!word %in% remove_reg)

edbf_term_counts_genre <- tidy_des_genre %>% 
  group_by(year, genre) %>% # group not only by year but also by genre
  count(word, sort = TRUE)

edbf_term_counts_genre $womword <- as.integer(grepl("women|feminist|feminism|gender|harassment|sexism|sexist", 
                                            x = edbf_term_counts_genre$word))

edbf_counts_children <- edbf_term_counts_genre %>%
  filter(genre == "Children") %>% # keep only 'Children' books
  group_by(year) %>%
  mutate(year_total = sum(n)) %>%
  filter(womword==1) %>%
  summarise(sum_wom = sum(n),
            year_total= min(year_total))

ggplot(edbf_counts_children, aes(year, sum_wom / year_total, group=1)) +
  geom_line() +
  xlab("Year") +
  ylab("% gender-related words") +
  scale_y_continuous(labels = scales::percent_format(),
                     expand = c(0, 0), limits = c(0, NA)) +
  theme_tufte(base_family = "Helvetica") 
```
```{r}
# you could also show both genre on one plot
edbf_counts_both <- edbf_term_counts_genre %>%
  group_by(year, genre) %>% 
  mutate(year_total = sum(n)) %>%
  filter(womword==1) %>%
  summarise(sum_wom = sum(n),
            year_total= min(year_total))

ggplot(edbf_counts_both, aes(year, sum_wom / year_total, group=genre, color=genre)) + # add the variable 'genre' as a group and color argument
  geom_line() +
  xlab("Year") +
  ylab("% gender-related words") +
  scale_y_continuous(labels = scales::percent_format(),
                     expand = c(0, 0), limits = c(0, NA)) +
  theme_tufte(base_family = "Helvetica") 
```



## B. Choose another set of terms by which to filter (e.g., race-related words) and plot their frequency over time.

```{r}
# continue use the cleaned data before, name it as new dataframe
edbf_term_counts_race <- edbf_term_counts

# select race-related words
race_terms <- "race|racial|racism|racist|ethnicity|ethnic|
               black|white|asian|african|afro|
               minority|minorities|immigrant|immigration|
               colonial|colonialism|postcolonial|
               diversity|multicultural|diaspora"

# denominate if related words appare in binary 0/1 way, show in raceword column
edbf_term_counts_race $raceword <- as.integer(grepl(race_terms, 
                                            x = edbf_term_counts$word))


#get counts by year and word
edbf_counts_race <- edbf_term_counts_race %>%
  group_by(year) %>%
  mutate(year_total = sum(n)) %>%  # create a new column 'year_total'（already group in year in each row）
  filter(raceword == 1) %>%  
  summarise(sum_race = sum(n), 
            year_total= min(year_total))  
head(edbf_counts_race)

# make a plot for frequency over time
ggplot(edbf_counts_race, aes(year, sum_race / year_total, group=1)) +  # calcuate frequency
  geom_line() +
  xlab("Year") +
  ylab("% race-related words") +
  scale_y_continuous(labels = scales::percent_format(),
                     expand = c(0, 0), limits = c(0, NA)) +
  theme_tufte(base_family = "Helvetica") 
```


