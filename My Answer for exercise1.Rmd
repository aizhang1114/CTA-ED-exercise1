---
title: "My Answer for exercise1"
author: "Ai Zhang"
date: "2026-02-03"
output: html_document
---


## beginning 

```{r}
install.packages('tidyverse')
install.packages('tidytext')
install.packages('ggthemes')
install.packages('readr')
install.packages('babynames')
```

```{r}
library(tidyverse) # loads dplyr, ggplot2, and others
library(tidytext) # includes set of functions useful for manipulating text
library(ggthemes) # includes a set of themes to make your visualizations look nice!
library(readr) # more informative and easy way to import data
library(babynames) #for gender predictions
```
```{r}
edbfdata <- read_csv("https://raw.githubusercontent.com/cjbarrie/RDL-Ed/main/02-text-as-data/data/edbookfestall.csv")
```
## Inspect and filter data

Our next job is to cut down this dataset to size, including only those columns that we need. But first we can inspect it to see what the existing column names are, and how each variable is coded.
```{r}
colnames(edbfdata)
```
```{r}
glimpse(edbfdata)
```
We can see that the description of each event is included in a column named “description” and the year of that event as “year.” So for now we’ll just keep these two. 
We use pipe %>% functions in the tidyverse package to quickly and efficiently select the columns we want from the edbfdata data.frame object. We pass this data to a new data.frame object, which we call “evdes.”
```{r}
evdes <- edbfdata %>% select(description, year)
head(evdes)
```

And let’s take a quick look at how many events there were over time at the festival. To do this, we first calculate the number of individual events (row observations) by year (column variable).
```{r}
# group in year and calculate how many events happen in each year
evtsperyr <- evdes %>%
  mutate(obs=1) %>% # create a column name obs and every event is 1
  group_by(year) %>%
  summarise(sum_events = sum(obs))
```

And then we can plot this using ggplot!
```{r}
ggplot(evtsperyr) +
  geom_line(aes(year, sum_events)) +
  theme_tufte(base_family = "Helvetica") + 
  scale_y_continuous(expand = c(0, 0), limits = c(0, NA))
```
## Tidy the text

get rid of any HTML and PHP encodings for e.g. bold font or paragraphs before the analysis because the data were obtained from an API that outputs data originally in HTML format
The below set of commands takes the event descriptions, extracts individual words, and counts the number of times they appear in each of the years covered by our book festival data.
```{r}
# get year and word for every word and date pair in the dataset

tidy_des <- evdes %>% 
  mutate(desc = tolower(description)) %>%
  unnest_tokens(word, desc) %>%
  filter(str_detect(word, "[a-z]")) # only keep the word include any letter in it
```

document is a important design part of a research

do a further tidy: delete stop words
```{r}
tidy_des <- tidy_des %>%
    filter(!word %in% stop_words$word)
```
```{r}
# 查看停用词类型
# 这是tidytext中的一个内置词库，里面都是不具有实质含义的语法词
stop_words
```

```{r}
tidy_des %>%
  count(word, sort = TRUE)
```

We can see that one of the most common words is “rsquo,” which is an HTML encoding for an apostrophe. This is a common issue in large-n text analysis and is a key step if you want to conduct reliably robust forms of text analysis. We’ll have another go using the the filter command, specifying that we only keep the words that are not included in the string of words rsquo, em, ndash, nbsp, lsquo.
```{r}
remove_reg <- c("&amp;","&lt;","&gt;","<p>", "</p>","&rsquo", "&lsquo;",  "&#39;", "<strong>", "</strong>", "rsquo", "em", "ndash", "nbsp", "lsquo", "strong")
                  
tidy_des <- tidy_des %>%
  filter(!word %in% remove_reg)
```

after remove it has been common
```{r}
tidy_des %>%
  count(word, sort = TRUE)
```
Let’s now collect these words into a data.frame object, which we’ll call edbf_term_counts:
```{r}
edbf_term_counts <- tidy_des %>% 
  group_by(year) %>%
  count(word, sort = TRUE)
```
head it
```{r}
head(edbf_term_counts)
```

Above is the pre-processing and cleaning steps------------------------------------------------------------------------------

## Analyze keywords
Okay, now we have our list of words, and the number of times they appear, we can tag those words we think might be related to issues of gender inequality and sexism. You may decide that this list is imprecise or inexhaustive. If so, then feel free to change the terms we are including after the grepl() function.

基于关键词进行主题标注。如果这个词看起来与“gender inequality/sexism”相关 → 标记为 1；不相关 → 标记为 0；
grepl() use for test，and feedback 'ture/false'
regex "|" means or，include any one them is 'ture'
as.integer()，make true/false into 1/0 binary code 
```{r}
edbf_term_counts$womword <- as.integer(grepl("women|feminist|feminism|gender|harassment|sexism|sexist", 
                                            x = edbf_term_counts$word))
```
```{r}
head(edbf_term_counts)
```
## Compute aggregate statistics

we have tagged individual words relating to gender inequality and feminism, we can sum up the number of times these words appear each year and then denominate them by the total number of words in the event descriptions.

```{r}
#get counts by year and word
edbf_counts <- edbf_term_counts %>%
  group_by(year) %>%
  mutate(year_total = sum(n)) %>%  # 创建一个新的列year_total（此时已经以年份为组了）
  filter(womword==1) %>%  # 选择标记为1的
  summarise(sum_wom = sum(n), # 把这一年里所有性别相关词的出现次数加起来，作为sum_wom
            year_total= min(year_total))  # 每一组只有一个total，所以这里写min/max都行
```
```{r}
head(edbf_counts)
```
## make a plot

Let’s take the count of words relating to gender in this dataset, and denominate them by the total number of words in these data per year.
And make a plot for it
```{r}
ggplot(edbf_counts, aes(year, sum_wom / year_total, group=1)) +
  geom_line() +
  xlab("Year") +
  ylab("% gender-related words") +
  scale_y_continuous(labels = scales::percent_format(),
                     expand = c(0, 0), limits = c(0, NA)) +
  theme_tufte(base_family = "Helvetica") 
```
We can add visual guides to draw attention to apparent changes in these data. Here, we might wish to signal the year of the #MeToo movement in 2017.
```{r}
ggplot(edbf_counts, aes(year, sum_wom / year_total, group=1)) +
  geom_line() +
  geom_vline(xintercept = 2017, col="red") +
  xlab("Year") +
  ylab("% gender-related words") +
  scale_y_continuous(labels = scales::percent_format(),
                     expand = c(0, 0), limits = c(0, NA)) +
  theme_tufte(base_family = "Helvetica")
```
And we could label why we are highlighting the year of 2017 by including a text label along the vertical line.
```{r}
ggplot(edbf_counts, aes(year, sum_wom / year_total, group=1)) +
  geom_line() +
  geom_vline(xintercept = 2017, col="red") +
  geom_text(aes(x=2017.1, label="#metoo year", y=.0015), 
            colour="black", angle=90, text=element_text(size=8)) +
  xlab("Year") +
  ylab("% gender-related words") +
  scale_y_continuous(labels = scales::percent_format(),
                     expand = c(0, 0), limits = c(0, NA)) +
  theme_tufte(base_family = "Helvetica")
```
## Bonus: gender prediction

the previous method maybe is inadequate or too expansive to answer the question at hand
Another way of measuring representation in cultural production is to measure the gender of the authors who spoke at these events.

We first create a new data.frame object, selecting just the columns for artist name and year. Then we generate a new column containing just the artist’s (author’s) first name:
```{r}
# get columns for artist name and year, omitting NAs
gendes <- edbfdata %>%
  select(artist, year) %>%
  na.omit() # 删除名字缺失的事件（行）

# generate new column with just the artist's (author's) first name
gendes$name <- sub(" .*", "", gendes$artist) # 提取first name
# sub(pattern, replacement, x) 的意思是：在字符串 x 中，找到第一次匹配 pattern 的地方，用 replacement 替换掉
# " .*" 表示从第一个空格开始，到字符串结尾的所有内容
# 使用""空字符串来替换，也就是从出现空格开始后面全删掉，也就是删掉所有last name
```

A set of packages called gender and genderdata used to make the process of predicting gender based on a given individual’s name pretty straightforward. This technique worked with reference to U.S. Social Security Administration baby name data.

Given that the most common gender associated with a given name changes over time, the function also allows us to specify the range of years for the cohort in question whose gender we are inferring. Given that we don’t know how wide the cohort of artists is that we have here, we could specify a broad range of 1920-2000.
```{r}
genpred <- gender(gendes$name,
       years = c(1920, 2000))
```


## create babynames package

The babynames package. contains, for each year, the number of children born with a given name, as well as their sex. With this information, we can then calculate the total number of individuals with a given name born for each sex in a given year.

Given we also have the total number of babies born in total cross these records, we can denominate (divide) the sums for each name by the total number of births for each sex in each year. We can take this proportion as representing the probability that a given individual in our Edinburgh Fringe dataset is male or female.

We first load the babynames package into the R environment as a data.frame object. Because the data.frame “babynames” is contained in the babynames package we can just call it as an object and store it with .

This dataset contains names for all years over a period 1800–2019. The variable “n” represents the number of babies born with the given name and sex in that year, and the “prop” represents, according to the package materials accessible here, “n divided by total number of applicants in that year, which means proportions are of people of that gender with that name born in that year.”

```{r}
babynames <- babynames
head(babynames)
```
We then calculate the total number of babies of female and male sex born in each year. Then we merge these to get a combined dataset of male and female baby names by year. We then merge this information back into the original babynames data.frame object.

```{r}
totals_female <- babynames %>%
  filter(sex=="F") %>%
  group_by(year) %>%
  summarise(total_female = sum(n))

totals_male <- babynames %>%
  filter(sex=="M") %>%
  group_by(year) %>%
  summarise(total_male = sum(n))

totals <- merge(totals_female, totals_male)

totsm <- merge(babynames, totals, by = "year")
head(totsm)
```

We can then calculate, for all babies born on or after 1920, the number of babies born with that name and sex. With this information, we can then get the proportion of all babies with a given name that were of a particular sex. For example, if 92% of babies born with the name “Mary” were female, this would give us a .92 probability that an individual with the name “Mary” is female.

We do this for every name in the dataset, excluding names for which the proportion is equal to .5; i.e., for names that we cannot adjudicate between whether they are more or less likely male or female.

```{r}
totprops <- totsm %>%
  filter(year >= 1920) %>%
  group_by(name, year) %>%
  mutate(sumname = sum(n),
         prop = ifelse(sumname==n, 1,
                       n/sumname)) %>%
  filter(prop!=.5) %>%
  group_by(name) %>%
  slice(which.max(prop)) %>%
  summarise(prop = max(prop),
            totaln = sum(n),
            name = max(name),
            sex = unique(sex))

head(totprops)
```
## back to gender prediction
Once we have our proportions for all names, we can then merge these back with the names of our artists from the Edinburgh Fringe Book Festival. We can then easily plot the proportion of artists at the Festival who are male versus female in each year of the Festival.

```{r}
ednameprops <- merge(totprops, gendes, by = "name")

ggplot(ednameprops, aes(x=year, fill = factor(sex))) +
  geom_bar(position = "fill") +
  xlab("Year") +
  ylab("% women authors") +
  labs(fill="") +
  scale_y_continuous(labels = scales::percent_format(accuracy = 1)) +
  theme_tufte(base_family = "Helvetica") +
  geom_abline(slope=0, intercept=0.5,  col = "black",lty=2)
```

Note that when we merged the proportions from th “babynames” data with our Edinburgh Fringe data we lost some observations. This is because some names in the Edinburgh Fringe data had no match in the “babynames” data. That's a kind of potential biases. Let’s look at the names that had no match:
```{r}
names1 <- ednameprops$name
names2 <- gendes$name
diffs <- setdiff(names2, names1)
diffs
```




exercises
## A. Filter the books by genre (selecting e.g., “Literature” or “Children”) and plot frequency of women-related words over time.
```{r}
# Go through the same process. I've highlighted the differences
evdes_genre <- edbfdata %>%
  select(description, year, genre) # but include genre variable here

evtsperyr_genre <- evdes_genre %>%
  mutate(obs=1) %>%
  group_by(year, genre) %>% # group not only by year but also by genre
  summarise(sum_events = sum(obs))

tidy_des_genre <- evdes_genre %>% 
  mutate(desc = tolower(description)) %>%
  unnest_tokens(word, desc) %>%
  filter(str_detect(word, "[a-z]"))

tidy_des_genre <- tidy_des_genre %>%
  filter(!word %in% stop_words$word) %>%
  filter(!word %in% remove_reg)

edbf_term_counts_genre <- tidy_des_genre %>% 
  group_by(year, genre) %>% # group not only by year but also by genre
  count(word, sort = TRUE)

edbf_term_counts_genre $womword <- as.integer(grepl("women|feminist|feminism|gender|harassment|sexism|sexist", 
                                            x = edbf_term_counts_genre$word))

edbf_counts_children <- edbf_term_counts_genre %>%
  filter(genre == "Children") %>% # keep only 'Children' books
  group_by(year) %>%
  mutate(year_total = sum(n)) %>%
  filter(womword==1) %>%
  summarise(sum_wom = sum(n),
            year_total= min(year_total))

ggplot(edbf_counts_children, aes(year, sum_wom / year_total, group=1)) +
  geom_line() +
  xlab("Year") +
  ylab("% gender-related words") +
  scale_y_continuous(labels = scales::percent_format(),
                     expand = c(0, 0), limits = c(0, NA)) +
  theme_tufte(base_family = "Helvetica") 
```
```{r}
# you could also show both genre on one plot
edbf_counts_both <- edbf_term_counts_genre %>%
  group_by(year, genre) %>% 
  mutate(year_total = sum(n)) %>%
  filter(womword==1) %>%
  summarise(sum_wom = sum(n),
            year_total= min(year_total))

ggplot(edbf_counts_both, aes(year, sum_wom / year_total, group=genre, color=genre)) + # add the variable 'genre' as a group and color argument
  geom_line() +
  xlab("Year") +
  ylab("% gender-related words") +
  scale_y_continuous(labels = scales::percent_format(),
                     expand = c(0, 0), limits = c(0, NA)) +
  theme_tufte(base_family = "Helvetica") 
```



## B. Choose another set of terms by which to filter (e.g., race-related words) and plot their frequency over time.

```{r}
# continue use the cleaned data before, name it as new dataframe
edbf_term_counts_race <- edbf_term_counts

# select race-related words
race_terms <- "race|racial|racism|racist|ethnicity|ethnic|
               black|white|asian|african|afro|
               minority|minorities|immigrant|immigration|
               colonial|colonialism|postcolonial|
               diversity|multicultural|diaspora"

# denominate if related words appare in binary 0/1 way, show in raceword column
edbf_term_counts_race $raceword <- as.integer(grepl(race_terms, 
                                            x = edbf_term_counts$word))


#get counts by year and word
edbf_counts_race <- edbf_term_counts_race %>%
  group_by(year) %>%
  mutate(year_total = sum(n)) %>%  # create a new column 'year_total'（already group in year in each row）
  filter(raceword == 1) %>%  
  summarise(sum_race = sum(n), 
            year_total= min(year_total))  
head(edbf_counts_race)

# make a plot for frequency over time
ggplot(edbf_counts_race, aes(year, sum_race / year_total, group=1)) +  # calcuate frequency
  geom_line() +
  xlab("Year") +
  ylab("% race-related words") +
  scale_y_continuous(labels = scales::percent_format(),
                     expand = c(0, 0), limits = c(0, NA)) +
  theme_tufte(base_family = "Helvetica") 
```


